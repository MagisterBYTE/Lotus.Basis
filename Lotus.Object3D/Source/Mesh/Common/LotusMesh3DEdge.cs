//=====================================================================================================================
// Проект: Модуль трехмерного объекта
// Раздел: Подсистема мешей
// Подраздел: Общее данные
// Автор: MagistrBYTE aka DanielDem <dementevds@gmail.com>
//---------------------------------------------------------------------------------------------------------------------
/** \file LotusMesh3DEdge.cs
*		Ребро трёхмерной полигональной сетки(меша).
*		Ребро представляет собой соединение двух вершин. Ребро может принадлежать как треугольникам с общими вершинами,
*	так и треугольникам с разными вершинами, но имеющим одинаковую позицию.
*/
//---------------------------------------------------------------------------------------------------------------------
// Версия: 1.0.0.0
// Последнее изменение от 30.04.2023
//=====================================================================================================================
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
//---------------------------------------------------------------------------------------------------------------------
using Lotus.Core;
using Lotus.Maths;
//=====================================================================================================================
namespace Lotus
{
	namespace Object3D
	{
		//-------------------------------------------------------------------------------------------------------------
		/** \addtogroup Object3DMeshCommon
		*@{*/
		//-------------------------------------------------------------------------------------------------------------
		/// <summary>
		/// Ребро трёхмерной полигональной сетки(меша)
		/// </summary>
		/// <remarks>
		/// <para>
		/// Ребро представляет собой соединение двух вершин. Ребро может принадлежать как треугольникам с общими вершинами,
		/// так и треугольникам с разными вершинами, но имеющим одинаковую позицию
		/// </para>
		/// <para>
		/// Для плоских трехмерных тел ребро также может принадлежать только одному треугольнику
		/// </para>
		/// </remarks>
		//-------------------------------------------------------------------------------------------------------------
		[Serializable]
		public struct CEdge3Df : IComparable<CEdge3Df>, IEquatable<CEdge3Df>, ICloneable
		{
			#region ======================================= СТАТИЧЕСКИЕ ДАННЫЕ ========================================
			/// <summary>
			/// Текстовый формат отображения параметров ребра
			/// </summary>
			public static String ToStringFormat = "{0}, {1}";
			#endregion

			#region ======================================= ДАННЫЕ ====================================================
			/// <summary>
			/// Индекс первой вершины первого треугольника
			/// </summary>
			public Int32 IndexVertex10;

			/// <summary>
			/// Индекс второй вершины первого треугольника
			/// </summary>
			public Int32 IndexVertex11;

			/// <summary>
			/// Индекс первой вершины второго треугольника
			/// </summary>
			public Int32 IndexVertex20;

			/// <summary>
			/// Индекс второй вершины второго треугольника
			/// </summary>
			public Int32 IndexVertex21;

			/// <summary>
			/// Индекс первого треугольника которому принадлежит ребро
			/// </summary>
			public Int32 IndexTriangle1;

			/// <summary>
			/// Индекс второго треугольника которому принадлежит ребро
			/// </summary>
			public Int32 IndexTriangle2;
			#endregion

			#region ======================================= СВОЙСТВА ==================================================
			/// <summary>
			/// Тип структурного элемента меша
			/// </summary>
			public TMeshElement MeshElement { get { return (TMeshElement.Edge); } }

			/// <summary>
			/// Статус простого ребра
			/// </summary>
			/// <remarks>
			/// Простое ребро принадлежит двум треугольника и при этом индексы вершин ссылаются на одни и те же вершины
			/// </remarks>
			public Boolean IsSimple
			{
				get
				{
					return (IndexTriangle1 != -1 && IndexTriangle2 != -1 && IsEqualsIndex());
				}
			}

			/// <summary>
			/// Статус общего ребра
			/// </summary>
			/// <remarks>
			/// Обще ребро принадлежит двум треугольника и при этом индексы вершин ссылаются на разные вершины
			/// </remarks>
			public Boolean IsCommon
			{
				get
				{
					return (IndexTriangle1 != -1 && IndexTriangle2 != -1 && !IsEqualsIndex());
				}
			}

			/// <summary>
			/// Статус внешнего ребра
			/// </summary>
			/// <remarks>
			/// Только для плоских трехмерных тел ребро также может принадлежать только одному треугольнику
			/// </remarks>
			public Boolean IsOuter
			{
				get
				{
					return (IndexTriangle2 == -1);
				}
			}
			#endregion

			#region ======================================= КОНСТРУКТОРЫ ==============================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует объект класса указанными параметрами
			/// </summary>
			/// <param name="iv1">Индекс первой вершины</param>
			/// <param name="iv2">Индекс второй вершины</param>
			/// <param name="index_triangle1">Индекс первого треугольника которому принадлежит ребро</param>
			/// <param name="index_triangle2">Индекс второго треугольника которому принадлежит ребро</param>
			//---------------------------------------------------------------------------------------------------------
			public CEdge3Df(Int32 iv1, Int32 iv2, Int32 index_triangle1 = -1, Int32 index_triangle2 = -1)
			{
				IndexVertex10 = iv1;
				IndexVertex11 = iv2;
				IndexVertex20 = -1;
				IndexVertex21 = -1;
				IndexTriangle1 = index_triangle1;
				IndexTriangle2 = index_triangle2;
			}
			#endregion

			#region ======================================= СИСТЕМНЫЕ МЕТОДЫ ==========================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Проверяет равен ли текущий объект другому объекту того же типа
			/// </summary>
			/// <param name="obj">Сравниваемый объект</param>
			/// <returns>Статус равенства объектов</returns>
			//---------------------------------------------------------------------------------------------------------
			public override Boolean Equals(Object obj)
			{
				if (obj != null)
				{
					if (GetType() == obj.GetType())
					{
						CEdge3Df edge = (CEdge3Df)obj;
						return Equals(edge);
					}
				}
				return base.Equals(obj);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Проверка равенства ребер
			/// </summary>
			/// <remarks>
			/// Ребра равны если индексы вершины на которые они ссылаются равны
			/// </remarks>
			/// <param name="other">Сравниваемое ребро</param>
			/// <returns>Статус равенства ребер</returns>
			//---------------------------------------------------------------------------------------------------------
			public Boolean Equals(CEdge3Df other)
			{
				return ((IndexVertex10 == other.IndexVertex10 && IndexVertex11 == other.IndexVertex11) ||
					(IndexVertex11 == other.IndexVertex10 && IndexVertex10 == other.IndexVertex11));
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Сравнение ребер для упорядочивания
			/// </summary>
			/// <param name="other">Ребро</param>
			/// <returns>Статус сравнения ребер</returns>
			//---------------------------------------------------------------------------------------------------------
			public Int32 CompareTo(CEdge3Df other)
			{
				if (IndexVertex10 > other.IndexVertex10)
				{
					return 1;
				}
				else
				{
					if (IndexVertex10 < other.IndexVertex10)
					{
						return -1;
					}
					else
					{
						return 0;
					}
				}
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Получение хеш-кода ребра
			/// </summary>
			/// <returns>Хеш-код ребра</returns>
			//---------------------------------------------------------------------------------------------------------
			public override Int32 GetHashCode()
			{
				return IndexVertex10.GetHashCode() ^ IndexVertex11.GetHashCode();
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Получение хеш-кода указанной ребра
			/// </summary>
			/// <param name="obj">Ребро</param>
			/// <returns>Хеш-код ребра</returns>
			//---------------------------------------------------------------------------------------------------------
			public Int32 GetHashCode(CEdge3Df obj)
			{
				return obj.GetHashCode();
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Полное копирование ребра
			/// </summary>
			/// <returns>Копия ребра</returns>
			//---------------------------------------------------------------------------------------------------------
			public Object Clone()
			{
				return MemberwiseClone();
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Преобразование к текстовому представлению
			/// </summary>
			/// <returns>Индексы вершин ребра</returns>
			//---------------------------------------------------------------------------------------------------------
			public override String ToString()
			{
				return (String.Format(ToStringFormat, IndexVertex10, IndexVertex11));
			}
			#endregion

			#region ======================================= СЛУЖЕБНЫЕ МЕТОДЫ ==========================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Проверка на равенство индексов
			/// </summary>
			/// <remarks>
			/// Так как индексы вершин в треугольники могут иметь разный  порядок формирования, то мы должны проверить
			/// в двух комбинациях
			/// </remarks>
			/// <returns>Статус равенства индексов</returns>
			//---------------------------------------------------------------------------------------------------------
			public Boolean IsEqualsIndex()
			{
				// 1) Вариант
				if((IndexVertex10 == IndexVertex20 && IndexVertex11 == IndexVertex21) ||
					(IndexVertex11 == IndexVertex20 && IndexVertex10 == IndexVertex21))
				{
					return (true);
				}
				return (false);
			}
			#endregion

			#region ======================================= ОБЩИЕ МЕТОДЫ ==============================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Полное дублирование ребра
			/// </summary>
			/// <returns>Дубликат ребра</returns>
			//---------------------------------------------------------------------------------------------------------
			public CEdge3Df Duplicate()
			{
				CEdge3Df copy = (CEdge3Df)MemberwiseClone();
				return (copy);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Проверка данного ребра что позиция вершин по его индексам совпадет(равна) указанными позициями
			/// </summary>
			/// <remarks>
			/// То есть сравниваются позиция вершины по индексу ребра и переданная позиция
			/// </remarks>
			/// <param name="vertices">Список вершин</param>
			/// <param name="p1">Первая позиция</param>
			/// <param name="p2">Вторая позиция</param>
			/// <returns>Статус совпадения (равенства)</returns>
			//---------------------------------------------------------------------------------------------------------
			public Boolean CheckFromPosition(CListVertex3D vertices, in Vector3Df p1, in Vector3Df p2)
			{
				// Проверяем первую пару
				if (IndexVertex10 != -1 && IndexVertex11 != -1)
				{
					Vector3Df pe1 = vertices.Vertices[IndexVertex10].Position;
					Vector3Df pe2 = vertices.Vertices[IndexVertex11].Position;

					if(Vector3Df.Approximately(in pe1, in p1) &&
						Vector3Df.Approximately(in pe2, in p2))
					{
						// Совпадает первая пара
						return (true);
					}
					else
					{
						if (Vector3Df.Approximately(in pe1, in p2) &&
							Vector3Df.Approximately(in pe2, in p1))
						{
							// Совпадает первая пара (обратный порядок)
							return (true);
						}
					}
				}

				// Проверяем вторую пару
				if (IndexVertex20 != -1 && IndexVertex21 != -1)
				{
					Vector3Df pe1 = vertices.Vertices[IndexVertex20].Position;
					Vector3Df pe2 = vertices.Vertices[IndexVertex21].Position;

					if (Vector3Df.Approximately(in pe1, in p1) &&
						Vector3Df.Approximately(in pe2, in p2))
					{
						// Совпадает вторая пара
						return (true);
					}
					else
					{
						if (Vector3Df.Approximately(in pe1, in p2) &&
							Vector3Df.Approximately(in pe2, in p1))
						{
							// Совпадает вторая пара (обратный порядок)
							return (true);
						}
					}
				}

				return (false);
			}
			#endregion
		}

		//-------------------------------------------------------------------------------------------------------------
		/// <summary>
		/// Вспомогательный класс реализующий список ребер
		/// </summary>
		//-------------------------------------------------------------------------------------------------------------
		[Serializable]
		public class CListEdge3D : ListArray<CEdge3Df>, ILotusMeshOperaiton
		{
			#region ======================================= ДАННЫЕ ====================================================
			/// <summary>
			/// Вершины
			/// </summary>
			public CListVertex3D Vertices;
			#endregion

			#region ======================================= СВОЙСТВА ==================================================
			/// <summary>
			/// Тип структурного элемента меша
			/// </summary>
			public TMeshElement MeshElement { get { return (TMeshElement.Edge); } }
			#endregion

			#region ======================================= КОНСТРУКТОРЫ ==============================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор по умолчанию инициализирует объект класса предустановленными значениями
			/// </summary>
			//---------------------------------------------------------------------------------------------------------
			public CListEdge3D()
			{
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует объект класса указанными параметрами
			/// </summary>
			/// <param name="vertices">Список вершин</param>
			//---------------------------------------------------------------------------------------------------------
			public CListEdge3D(CListVertex3D vertices)
			{
				Vertices = vertices;
			}
			#endregion

			#region ======================================= ILotusMeshOperaiton - МЕТОДЫ ==============================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Смещение вершин
			/// </summary>
			/// <param name="offset">Вектор смещения</param>
			//---------------------------------------------------------------------------------------------------------
			public void Move(Vector3Df offset)
			{
				for (Int32 i = 0; i < mCount; i++)
				{
					Vertices.Vertices[mArrayOfItems[i].IndexVertex10].Position += offset;
					Vertices.Vertices[mArrayOfItems[i].IndexVertex11].Position += offset;
					if(mArrayOfItems[i].IndexTriangle2 != -1 && !mArrayOfItems[i].IsEqualsIndex())
					{
						Vertices.Vertices[mArrayOfItems[i].IndexVertex20].Position += offset;
						Vertices.Vertices[mArrayOfItems[i].IndexVertex21].Position += offset;
					}
				}
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Врашение вершин
			/// </summary>
			/// <param name="rotation">Кватернион вращения</param>
			//---------------------------------------------------------------------------------------------------------
			public void Rotate(Quaternion3Df rotation)
			{

			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Однородное масштабирование вершин
			/// </summary>
			/// <param name="scale">Масштаб</param>
			//---------------------------------------------------------------------------------------------------------
			public void Scale(Single scale)
			{

			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Масштабирование вершины
			/// </summary>
			/// <param name="scale">Масштаб</param>
			//---------------------------------------------------------------------------------------------------------
			public void Scale(Vector3Df scale)
			{

			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Обратить нормали
			/// </summary>
			//---------------------------------------------------------------------------------------------------------
			public void FlipNormals()
			{

			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Обратить развёртку текстурных координат по горизонтали 
			/// </summary>
			/// <param name="channel">Канал текстурных координат</param>
			//---------------------------------------------------------------------------------------------------------
			public void FlipUVHorizontally(Int32 channel = 0)
			{

			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Обратить развёртку текстурных координат по вертикали 
			/// </summary>
			/// <param name="channel">Канал текстурных координат</param>
			//---------------------------------------------------------------------------------------------------------
			public void FlipUVVertically(Int32 channel = 0)
			{

			}
			#endregion

			#region ======================================= ОБЩИЕ МЕТОДЫ ==============================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Поиск ребер меша по индексам вершин которые ему принадлежат
			/// </summary>
			/// <param name="iv1">Индекс первой вершины</param>
			/// <param name="iv2">Индекс второй вершины</param>
			/// <returns>Индекс ребра или -1 если такого ребра не оказалось</returns>
			//---------------------------------------------------------------------------------------------------------
			public Int32 FindEdgeOfVertex(Int32 iv1, Int32 iv2)
			{
				Vector3Df p1 = Vertices[iv1].Position;
				Vector3Df p2 = Vertices[iv2].Position;

				for (Int32 i = 0; i < mCount; i++)
				{
					if (mArrayOfItems[i].CheckFromPosition(Vertices, in p1, in p2))
					{
						return (i);
					}
				}

				return (-1);
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Получение списка внешних ребер
			/// </summary>
			/// <remarks>
			/// Применяется в отношение плоских фигур для определения их контура
			/// </remarks>
			/// <returns>Cписок внешних ребер</returns>
			//---------------------------------------------------------------------------------------------------------
			public CListEdge3D GetOuterEdge()
			{
				CListEdge3D outer_edges = new CListEdge3D();

				for (Int32 i = 0; i < mCount; i++)
				{
					if (mArrayOfItems[i].IndexTriangle2 == -1)
					{
						outer_edges.Add(mArrayOfItems[i]);
					}
				}

				return (outer_edges);
			}
			#endregion
		}
		//-------------------------------------------------------------------------------------------------------------
		/**@}*/
		//-------------------------------------------------------------------------------------------------------------
	}
}
//=====================================================================================================================