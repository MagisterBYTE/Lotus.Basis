//=====================================================================================================================
// Проект: Модуль трехмерного объекта
// Раздел: Подсистема мешей
// Подраздел: Плоскостные трехмерные примитивы
// Автор: MagistrBYTE aka DanielDem <dementevds@gmail.com>
//---------------------------------------------------------------------------------------------------------------------
/** \file LotusMesh3DPlanar.cs
*		Определение базового плоскостного трехмерного примитива.
*/
//---------------------------------------------------------------------------------------------------------------------
// Версия: 1.0.0.0
// Последнее изменение от 27.03.2022
//=====================================================================================================================
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
//---------------------------------------------------------------------------------------------------------------------
using Lotus.Core;
using Lotus.Maths;
//=====================================================================================================================
namespace Lotus
{
	namespace Object3D
	{
		//-------------------------------------------------------------------------------------------------------------
		//! \defgroup Object3DMeshPlanar Плоскостные трехмерные примитивы
		//! Плоскостные трехмерные примитивы - это плоские примитивы которые создаются в какой либо определенной плоскости
		//! \ingroup Object3DMesh
		/*@{*/
		//-------------------------------------------------------------------------------------------------------------
		/// <summary>
		/// Базовый плоскостной трехмерный примитив
		/// </summary>
		/// <remarks>
		/// 
		/// </remarks>
		//-------------------------------------------------------------------------------------------------------------
		[Serializable]
		public class CMeshPlanar3Df : CMesh3Df
		{
			#region ======================================= СТАТИЧЕСКИЕ МЕТОДЫ ========================================
			#endregion

			#region ======================================= ДАННЫЕ ====================================================
			internal Maths.TDimensionPlane mPlaneType;
			#endregion

			#region ======================================= СВОЙСТВА ==================================================
			/// <summary>
			/// Тип плоскости в которой расположен примитив
			/// </summary>
			public Maths.TDimensionPlane PlaneType
			{
				get { return mPlaneType; }
				set
				{
					mPlaneType = value;
					ChangePlaneType();
				}
			}
			#endregion

			#region ======================================= КОНСТРУКТОРЫ ==============================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор по умолчанию инициализирует объект класса предустановленными значениями
			/// </summary>
			//---------------------------------------------------------------------------------------------------------
			public CMeshPlanar3Df()
				:base()
			{
			}
			#endregion

			#region ======================================= СЛУЖЕБНЫЕ МЕТОДЫ ==========================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Изменение плоскости в которой расположен примитив
			/// </summary>
			//---------------------------------------------------------------------------------------------------------
			protected virtual void ChangePlaneType()
			{

			}
			#endregion

			#region ======================================= ОБЩИЕ МЕТОДЫ ==============================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Получение вектора перпендикулярного плоскости
			/// </summary>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector3Df GetPerpendicularVector()
			{
				if (mPlaneType == Maths.TDimensionPlane.XZ)
				{
					return (Vector3Df.Up);
				}
				else
				{
					if (mPlaneType == Maths.TDimensionPlane.ZY)
					{
						return (Vector3Df.Right);
					}
					else
					{
						return (-Vector3Df.Forward);
					}
				}
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Получение вектора на соответствующей плоскости на основу указанных двухмерных координат
			/// </summary>
			/// <param name="x">Координта по X</param>
			/// <param name="y">Координта по Y</param>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector3Df GetPlaneVector(Single x, Single y)
			{
				if (mPlaneType == Maths.TDimensionPlane.XZ)
				{
					return (new Vector3Df(x, 0, y));
				}
				else
				{
					if (mPlaneType == Maths.TDimensionPlane.ZY)
					{
						return (new Vector3Df(0, y, x));
					}
					else
					{
						return (new Vector3Df(x, y, 0));
					}
				}
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Получение вектора на соответствующей плоскости на основу указанных двухмерных координат
			/// </summary>
			/// <param name="x">Координта по X</param>
			/// <param name="y">Координта по Y</param>
			/// <param name="vector_save">Вектор для сохранения значимой координаты</param>
			/// <returns>Вектор</returns>
			//---------------------------------------------------------------------------------------------------------
			public Vector3Df GetPlaneVector(Single x, Single y, Vector3Df vector_save)
			{
				if (mPlaneType == Maths.TDimensionPlane.XZ)
				{
					return (new Vector3Df(x, vector_save.Y, y));
				}
				else
				{
					if (mPlaneType == Maths.TDimensionPlane.ZY)
					{
						return (new Vector3Df(vector_save.X, y, x));
					}
					else
					{
						return (new Vector3Df(x, y, vector_save.Z));
					}
				}
			}
			#endregion
		}
		//-------------------------------------------------------------------------------------------------------------
		/*@}*/
		//-------------------------------------------------------------------------------------------------------------
	}
}
//=====================================================================================================================